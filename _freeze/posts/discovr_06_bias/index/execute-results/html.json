{
  "hash": "c74159d37fc96ba4c0984fa9075ea4f5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"discovr_06 - The Beast of Bias\"\nauthor: \"Colin Madland\"\ndate: \"2024-04-16\"\ncategories: [bias, R, discovr]\neditor: visual\nimage: \"ellie.jpeg\"\nfreeze: auto\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse, ggplot2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\ndownload_tib <- here::here(\"data/download_festival.csv\") |> readr::read_csv()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 810 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): gender\ndbl (4): ticket_no, day_1, day_2, day_3\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\ndownload_tib <- download_tib |> \ndplyr::mutate(\n    ticket_no = as.character(ticket_no),\n    gender = forcats::as_factor(gender) |>\n      forcats::fct_relevel(\"Male\", \"Female\", \"Non-binary\")\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload_tib\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 810 × 5\n   ticket_no gender day_1 day_2 day_3\n   <chr>     <fct>  <dbl> <dbl> <dbl>\n 1 2111      Male    2.64  1.35  1.61\n 2 2229      Female  0.97  1.41  0.29\n 3 2338      Male    0.84 NA    NA   \n 4 2384      Female  3.03 NA    NA   \n 5 2401      Female  0.88  0.08 NA   \n 6 2405      Male    0.85 NA    NA   \n 7 2467      Female  1.56 NA    NA   \n 8 2478      Female  3.02 NA    NA   \n 9 2490      Male    2.29 NA    NA   \n10 2504      Female  1.11  0.44  0.55\n# ℹ 800 more rows\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-important collapse=\"true\"}\n## Which of the following describes tidy data?\n\nData that are arranged such that scores on a variable appear in a single column and rows represent a combination of the attributes of those scores – the entity from which the scores came, when the score was recorded, etc. Scores from a single entity can appear over multiple rows where each row represents a combination of the attributes of the score – for example, levels of an independent variable or time point at which the score was recorded.\n:::\n\n::: {.callout-important collapse=\"true\"}\n## Are the download data in tidy or messy format?\n\nMessy\n\nCorrect - well done! The download data are messy because the hygiene scores on different days are spread across different columns rather than being in a single colum with an additional column to indicate the day of the festival that the hygiene score was measured.\n:::\n\n`tidyr` has two functions for converting data from messy to tidy. - `pivot_longer()` takes columns and puts them into rosw to make messy data tidy - `pivot_wider()` takes rows and puts them in columns to make tidy data messy\n\n## Making messy data tidy\n\n```         \ntidyr::pivot_longer(\n  data = tibble,\n  cols = column_names,\n  names_to = \"name_of_column_to_contain_variable_names\",\n  values_to = \"name_of_column_to_contain_values\",\n)\n```\n\n`tibble`\n\n:   Name of the messy tibble\n\n`column_names`\n\n:   list of columns to be restructured into rows\n\n`names_to`\n\n:   name for the new variable that contains names of the original columns\n\n`value_to`\n\n:   name for the new variable that will contain the values.\n\n## Code example\n\n-   in `download_tib`, there are three columns/variables that need to be restructured into rows\n-   specify the variables using `day_1:day_3`\n-   scores in these columns represent hygiene scores, so we could use `hygiene` as the variable to contain values after restructuring\n-   columns we are transforming represent different days at the festival, so we can use `day` as the name of the variable created to contain column names\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload_tidy_tib <- download_tib |>  # create a new object called `download_tidy_tib`\n  tidyr::pivot_longer(                              # use the `pivot_longer()` function from `tidyr`\n  cols = day_1:day_3,                           # specify columns `day_1:day_3` for restructuring\n  names_to = \"day\",                             # names of the columns be placed in a variable called `day`\n  values_to = \"hygiene\",                        # values of the columns placed in a variable called `hygiene`\n)\ndownload_tidy_tib                               # display the new object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,430 × 4\n   ticket_no gender day   hygiene\n   <chr>     <fct>  <chr>   <dbl>\n 1 2111      Male   day_1    2.64\n 2 2111      Male   day_2    1.35\n 3 2111      Male   day_3    1.61\n 4 2229      Female day_1    0.97\n 5 2229      Female day_2    1.41\n 6 2229      Female day_3    0.29\n 7 2338      Male   day_1    0.84\n 8 2338      Male   day_2   NA   \n 9 2338      Male   day_3   NA   \n10 2384      Female day_1    3.03\n# ℹ 2,420 more rows\n```\n\n\n:::\n:::\n\n\n\n## Tidying labels\n\n-   the values in `day` match the original column names exactly (`day_1`)\n-   we want sentence case (`Day 1`)\n-   use `stringr`\n\n```         \ndownload_tidy_tib <- download_tidy_tib |>   # recreates `download_tidy_tib` from itself\n   dplyr::mutate(                                             # uses `dplyr::mutate` to recreate the variable `day`\n    day = stringr::str_to_sentence(day) |> stringr::str_replace(\"_\", \" \")                                                # uses `stringr::str_to_sentence` to capitalize the d, then `str_replace()` to find the underscore and replace it with a space\n  )\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload_tidy_tib <- download_tidy_tib |> \n   dplyr::mutate(\n    day = stringr::str_to_sentence(day) |> stringr::str_replace(\"_\", \" \")\n  )\n  download_tidy_tib\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,430 × 4\n   ticket_no gender day   hygiene\n   <chr>     <fct>  <chr>   <dbl>\n 1 2111      Male   Day 1    2.64\n 2 2111      Male   Day 2    1.35\n 3 2111      Male   Day 3    1.61\n 4 2229      Female Day 1    0.97\n 5 2229      Female Day 2    1.41\n 6 2229      Female Day 3    0.29\n 7 2338      Male   Day 1    0.84\n 8 2338      Male   Day 2   NA   \n 9 2338      Male   Day 3   NA   \n10 2384      Female Day 1    3.03\n# ℹ 2,420 more rows\n```\n\n\n:::\n:::\n\n\n\n\\## Making tidy data messy\n\n-   `pivot_wider()` reverses the process above\n\n```         \ntidyr::pivot_wider(\n  data = tibble,  # tibble to be restructured\n  id_cols = variables_that_you_do_not_want_to_restructure,\n  names_from = \"variable_containing_the_names_of_columns\",\n  values_from = \" variable_containing_the_scores\",\n)\n```\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload_tib <- download_tidy_tib |> \n  tidyr::pivot_wider(\n  id_cols = c(ticket_no, gender),\n  names_from = \"day\",\n  values_from = \"hygiene\",\n)\ndownload_tib\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 810 × 5\n   ticket_no gender `Day 1` `Day 2` `Day 3`\n   <chr>     <fct>    <dbl>   <dbl>   <dbl>\n 1 2111      Male      2.64    1.35    1.61\n 2 2229      Female    0.97    1.41    0.29\n 3 2338      Male      0.84   NA      NA   \n 4 2384      Female    3.03   NA      NA   \n 5 2401      Female    0.88    0.08   NA   \n 6 2405      Male      0.85   NA      NA   \n 7 2467      Female    1.56   NA      NA   \n 8 2478      Female    3.02   NA      NA   \n 9 2490      Male      2.29   NA      NA   \n10 2504      Female    1.11    0.44    0.55\n# ℹ 800 more rows\n```\n\n\n:::\n:::\n\n\n\n-   in this case, having the variable names in sentence case (Day 1), is inconvenient because we will always have to put them in backticks\n-   rename using `dplyr::rename_with`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndownload_tib <- download_tib |> \n  dplyr::rename_with(.cols = starts_with(\"Day\"), # finds all columns w/i download_tib that begin with the word `Day'\n     .fn = \\(column) stringr::str_replace(string = column, # creates a lambda or anonymous function that will be applied to the variables that begin with Day\n        pattern = \"Day \",  # with next line, tells the function what to do\n        replacement = \"day_\")\n)\n\ndownload_tib\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 810 × 5\n   ticket_no gender day_1 day_2 day_3\n   <chr>     <fct>  <dbl> <dbl> <dbl>\n 1 2111      Male    2.64  1.35  1.61\n 2 2229      Female  0.97  1.41  0.29\n 3 2338      Male    0.84 NA    NA   \n 4 2384      Female  3.03 NA    NA   \n 5 2401      Female  0.88  0.08 NA   \n 6 2405      Male    0.85 NA    NA   \n 7 2467      Female  1.56 NA    NA   \n 8 2478      Female  3.02 NA    NA   \n 9 2490      Male    2.29 NA    NA   \n10 2504      Female  1.11  0.44  0.55\n# ℹ 800 more rows\n```\n\n\n:::\n:::\n\n\n\n## Spotting outliers\n\nTwo ways:\n\n-   visualize the data and look for unusual cases\n-   look for values that are poorly predicted by the model, using model residuals as described in DSUR\n\n::: {.callout-important collapse=\"true\"}\n## What are the model residuals?\n\n-   The differences between the values a model predicts and the values observed in the data on which the model is based\n:::\n\n## Histograms and Boxplots",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}